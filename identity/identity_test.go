package identity

import (
	"crypto/ed25519"
	"testing"

	"github.com/corpo/qntm/pkg/types"
)

func TestManager_GenerateIdentity(t *testing.T) {
	manager := NewManager()
	
	identity, err := manager.GenerateIdentity()
	if err != nil {
		t.Fatalf("Failed to generate identity: %v", err)
	}
	
	// Validate the generated identity
	err = manager.ValidateIdentity(identity)
	if err != nil {
		t.Fatalf("Generated identity is invalid: %v", err)
	}
	
	// Check that key ID is correctly computed
	expectedKeyID := manager.KeyIDFromPublicKey(identity.PublicKey)
	if identity.KeyID != expectedKeyID {
		t.Error("Key ID does not match expected value")
	}
}

func TestManager_KeyIDOperations(t *testing.T) {
	manager := NewManager()
	
	// Generate test identity
	identity, err := manager.GenerateIdentity()
	if err != nil {
		t.Fatalf("Failed to generate test identity: %v", err)
	}
	
	// Test key ID computation
	keyID := manager.KeyIDFromPublicKey(identity.PublicKey)
	if keyID != identity.KeyID {
		t.Error("KeyIDFromPublicKey does not match stored key ID")
	}
	
	// Test key ID verification
	if !manager.VerifyKeyID(identity.PublicKey, identity.KeyID) {
		t.Error("VerifyKeyID failed for correct key ID")
	}
	
	// Test with wrong key ID
	wrongKeyID := types.KeyID{0xFF, 0xFF, 0xFF, 0xFF} // clearly wrong
	if manager.VerifyKeyID(identity.PublicKey, wrongKeyID) {
		t.Error("VerifyKeyID should fail for wrong key ID")
	}
}

func TestManager_Serialization(t *testing.T) {
	manager := NewManager()
	
	// Generate test identity
	original, err := manager.GenerateIdentity()
	if err != nil {
		t.Fatalf("Failed to generate test identity: %v", err)
	}
	
	// Serialize
	data, err := manager.SerializeIdentity(original)
	if err != nil {
		t.Fatalf("Failed to serialize identity: %v", err)
	}
	
	if len(data) == 0 {
		t.Error("Serialized data is empty")
	}
	
	// Deserialize
	deserialized, err := manager.DeserializeIdentity(data)
	if err != nil {
		t.Fatalf("Failed to deserialize identity: %v", err)
	}
	
	// Compare
	if !identitiesEqual(original, deserialized) {
		t.Error("Deserialized identity does not match original")
	}
	
	// Validate deserialized identity
	err = manager.ValidateIdentity(deserialized)
	if err != nil {
		t.Fatalf("Deserialized identity is invalid: %v", err)
	}
}

func TestManager_PublicKeyStringConversion(t *testing.T) {
	manager := NewManager()
	
	// Generate test identity
	identity, err := manager.GenerateIdentity()
	if err != nil {
		t.Fatalf("Failed to generate test identity: %v", err)
	}
	
	// Convert to string
	pubkeyStr := manager.PublicKeyToString(identity.PublicKey)
	if len(pubkeyStr) == 0 {
		t.Error("Public key string is empty")
	}
	
	// Convert back
	pubkey, err := manager.PublicKeyFromString(pubkeyStr)
	if err != nil {
		t.Fatalf("Failed to parse public key from string: %v", err)
	}
	
	// Compare
	if !ed25519.PublicKey(pubkey).Equal(identity.PublicKey) {
		t.Error("Public key does not match after string round-trip")
	}
}

func TestManager_KeyIDStringConversion(t *testing.T) {
	manager := NewManager()
	
	// Generate test identity
	identity, err := manager.GenerateIdentity()
	if err != nil {
		t.Fatalf("Failed to generate test identity: %v", err)
	}
	
	// Convert to string
	keyIDStr := manager.KeyIDToString(identity.KeyID)
	if len(keyIDStr) == 0 {
		t.Error("Key ID string is empty")
	}
	
	// Convert back
	keyID, err := manager.KeyIDFromString(keyIDStr)
	if err != nil {
		t.Fatalf("Failed to parse key ID from string: %v", err)
	}
	
	// Compare
	if keyID != identity.KeyID {
		t.Error("Key ID does not match after string round-trip")
	}
}

func TestManager_RandomGeneration(t *testing.T) {
	manager := NewManager()
	
	// Test random bytes generation
	bytes1, err := manager.GenerateRandomBytes(32)
	if err != nil {
		t.Fatalf("Failed to generate random bytes: %v", err)
	}
	
	if len(bytes1) != 32 {
		t.Errorf("Generated bytes length is %d, want 32", len(bytes1))
	}
	
	bytes2, err := manager.GenerateRandomBytes(32)
	if err != nil {
		t.Fatalf("Failed to generate second set of random bytes: %v", err)
	}
	
	// They should be different (extremely unlikely to be the same)
	if string(bytes1) == string(bytes2) {
		t.Error("Two random byte generations produced identical results")
	}
	
	// Test conversation ID generation
	convID1, err := manager.GenerateConversationID()
	if err != nil {
		t.Fatalf("Failed to generate conversation ID: %v", err)
	}
	
	convID2, err := manager.GenerateConversationID()
	if err != nil {
		t.Fatalf("Failed to generate second conversation ID: %v", err)
	}
	
	if convID1 == convID2 {
		t.Error("Two conversation ID generations produced identical results")
	}
	
	// Test message ID generation
	msgID1, err := manager.GenerateMessageID()
	if err != nil {
		t.Fatalf("Failed to generate message ID: %v", err)
	}
	
	msgID2, err := manager.GenerateMessageID()
	if err != nil {
		t.Fatalf("Failed to generate second message ID: %v", err)
	}
	
	if msgID1 == msgID2 {
		t.Error("Two message ID generations produced identical results")
	}
}

func TestManager_ValidateIdentity(t *testing.T) {
	manager := NewManager()
	
	// Test with nil identity
	err := manager.ValidateIdentity(nil)
	if err == nil {
		t.Error("ValidateIdentity should fail with nil identity")
	}
	
	// Test with valid identity
	validIdentity, err := manager.GenerateIdentity()
	if err != nil {
		t.Fatalf("Failed to generate valid identity: %v", err)
	}
	
	err = manager.ValidateIdentity(validIdentity)
	if err != nil {
		t.Fatalf("ValidateIdentity failed for valid identity: %v", err)
	}
	
	// Test with corrupted private key
	corruptedIdentity := &types.Identity{
		PrivateKey: make([]byte, 10), // wrong length
		PublicKey:  validIdentity.PublicKey,
		KeyID:      validIdentity.KeyID,
	}
	
	err = manager.ValidateIdentity(corruptedIdentity)
	if err == nil {
		t.Error("ValidateIdentity should fail with corrupted private key")
	}
	
	// Test with corrupted public key
	corruptedIdentity2 := &types.Identity{
		PrivateKey: validIdentity.PrivateKey,
		PublicKey:  make([]byte, 10), // wrong length
		KeyID:      validIdentity.KeyID,
	}
	
	err = manager.ValidateIdentity(corruptedIdentity2)
	if err == nil {
		t.Error("ValidateIdentity should fail with corrupted public key")
	}
	
	// Test with wrong key ID
	wrongKeyID := types.KeyID{0xFF, 0xFF, 0xFF, 0xFF}
	corruptedIdentity3 := &types.Identity{
		PrivateKey: validIdentity.PrivateKey,
		PublicKey:  validIdentity.PublicKey,
		KeyID:      wrongKeyID,
	}
	
	err = manager.ValidateIdentity(corruptedIdentity3)
	if err == nil {
		t.Error("ValidateIdentity should fail with wrong key ID")
	}
}

// Helper function to compare identities
func identitiesEqual(a, b *types.Identity) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	
	return ed25519.PrivateKey(a.PrivateKey).Equal(b.PrivateKey) &&
		ed25519.PublicKey(a.PublicKey).Equal(b.PublicKey) &&
		a.KeyID == b.KeyID
}